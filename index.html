<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Kindlicher Endlos Platformer</title>
  <script src="https://cdn.jsdelivr.net/npm/p5@2.0.5/lib/p5.js"></script>
</head>
<body>
<script>
let player;
let platforms = [];
let islands = [];
let trees = [];
let clouds = [];
let collectibles = [];
let gravity = 0.6;
let jumpForce = -12;
let scrollSpeed = 0;
let scrollOffset = 0;
let score = 0;
let lives = 3;
let maxLives = 5;
let checkpoint;
let gameState = 'playing';
let restartButton;
let lastPlatformY = 0;

function setup() {
  createCanvas(800, 600);
  checkpoint = {x: 0, y: height - 50};
  resetGame();
}

function resetGame() {
  player = {
    x: width / 2,
    y: height - 50,
    w: 30,
    h: 30,
    vy: 0,
    jumpsLeft: 2,
    rotation: 0,
    rotationSpeed: 0
  };
  platforms = [];
  islands = [];
  trees = [];
  clouds = [];
  collectibles = [];
  platforms.push({
    x: 0,
    y: height - 20,
    w: width * 2,
    h: 20,
    type: 'normal'
  });
  lastPlatformY = height - 20;
  clouds.push({ x: width / 2, y: 100 });
  islands.push({ x: width / 2 + 100, y: height - 20, w: 50, h: 20 });
  trees.push({ x: width / 2 + 100 + 25, y: height - 20 });
  scrollOffset = 0;
  score = 0;
  lives = 3;
  gameState = 'playing';
  if (restartButton) {
    restartButton.remove();
  }
  loop();
}

function draw() {
  if (gameState === 'gameover') {
    return;
  }
  
  // Blauer Himmel-Hintergrund
  background(135, 206, 235);
  
  // Lava am Boden zeichnen
  fill(255, 69, 0);
  rect(0, height - 10, width, 10);
  
  // Scroll-Speed basierend auf Input
  scrollSpeed = 0;
  if (keyIsDown(RIGHT_ARROW) || key === 'd' || key === 'D') {
    scrollSpeed = 3;
    console.log('Right/D pressed'); // Debugging
  }
  if (keyIsDown(LEFT_ARROW) || key === 'a' || key === 'A') {
    scrollSpeed = -3;
    console.log('Left/A pressed'); // Debugging
  }
  scrollOffset += scrollSpeed;
  
  // Rotation bei Bewegung
  if (player.jumpsLeft === 2) {
    player.rotationSpeed = scrollSpeed * 0.05;
  }
  
  // Spieler-Physik
  player.vy += gravity;
  player.y += player.vy;
  player.rotation += player.rotationSpeed;
  
  // Lava (Boden) prüfen - Leben verlieren
  if (player.y + player.h > height) {
    lives--;
    if (lives > 0) {
      // Prüfe Plattform unter Checkpoint
      let checkpointSafe = false;
      let allPlatforms = [...platforms, ...islands];
      for (let platform of allPlatforms) {
        let platformScreenX = platform.x - scrollOffset;
        if (player.x + player.w > platformScreenX && 
            player.x < platformScreenX + platform.w &&
            abs(checkpoint.y - (platform.y - player.h)) < 10) {
          checkpointSafe = true;
          break;
        }
      }
      if (!checkpointSafe) {
        // Neue Plattform unter Checkpoint
        let newPlatformX = checkpoint.x + width / 2;
        let newPlatformY = checkpoint.y + player.h;
        platforms.push({
          x: newPlatformX,
          y: newPlatformY,
          w: 100,
          h: 20,
          type: 'normal'
        });
        lastPlatformY = newPlatformY;
        console.log('Added safe platform at checkpoint:', newPlatformX, newPlatformY); // Debugging
      }
      // Respawn bei Checkpoint
      player.x = width / 2;
      player.y = checkpoint.y;
      scrollOffset = checkpoint.x;
      player.vy = 0;
      player.jumpsLeft = 2;
      player.rotation = 0;
      player.rotationSpeed = 0;
    } else {
      gameOver();
    }
    return;
  }
  
  // Kollisionserkennung für Plattformen und Inseln
  let onGround = false;
  let allPlatforms = [...platforms, ...islands];
  for (let platform of allPlatforms) {
    let platformScreenX = platform.x - scrollOffset;
    
    if (player.x + player.w > platformScreenX && 
        player.x < platformScreenX + platform.w &&
        player.y + player.h > platform.y &&
        player.y + player.h < platform.y + platform.h + player.vy &&
        player.vy >= 0) {
      player.y = platform.y - player.h;
      player.vy = 0;
      player.jumpsLeft = 2;
      player.rotationSpeed = 0;
      player.rotation = 0;
      onGround = true;
    }
  }
  
  // Collectibles prüfen
  for (let i = collectibles.length - 1; i >= 0; i--) {
    let coll = collectibles[i];
    let collScreenX = coll.x - scrollOffset;
    if (player.x + player.w > collScreenX && 
        player.x < collScreenX + 20 &&
        player.y + player.h > coll.y && 
        player.y < coll.y + 20) {
      if (coll.type === 'life' && lives < maxLives) {
        lives++;
      } else if (coll.type === 'checkpoint') {
        checkpoint = {x: scrollOffset, y: coll.y - player.h};
      }
      collectibles.splice(i, 1);
    }
  }
  
  // Plattformen generieren (erreichbar)
  let lastPlatform = platforms[platforms.length - 1] || islands[islands.length - 1];
  if (lastPlatform.x - scrollOffset + lastPlatform.w < width) {
    let newX = lastPlatform.x + lastPlatform.w + random(50, 120);
    let newY = lastPlatformY + random(-80, 80);
    newY = constrain(newY, height * 0.4, height * 0.8);
    let newW = random(80, 180);
    let platType = random(['normal', 'high', 'long']);
    if (platType === 'high') newY -= 30;
    if (platType === 'long') newW += 50;
    platforms.push({
      x: newX,
      y: newY,
      w: newW,
      h: 20,
      type: platType
    });
    lastPlatformY = newY;
    
    // Selten eine Insel mit Collectible
    if (random() < 0.1) {
      let islandX = newX + random(150, 250);
      let islandY = lastPlatformY + random(-80, 80);
      islandY = constrain(islandY, height * 0.4, height * 0.6);
      islands.push({
        x: islandX,
        y: islandY,
        w: 60,
        h: 20
      });
      let collType = random() < 0.5 ? 'life' : 'checkpoint';
      collectibles.push({
        x: islandX + 20,
        y: islandY - 20,
        type: collType
      });
      if (random() < 0.5) {
        trees.push({ x: islandX + 30, y: islandY });
      }
      lastPlatformY = islandY;
    }
  }
  
  // Wolken generieren
  if (frameCount % 300 === 0) {
    clouds.push({ x: scrollOffset + width + random(50, 100), y: random(50, 150) });
  }
  
  // Alte Objekte entfernen
  platforms = platforms.filter(p => p.x - scrollOffset + p.w > 0);
  islands = islands.filter(i => i.x - scrollOffset + i.w > 0);
  trees = trees.filter(t => t.x - scrollOffset + 50 > 0);
  clouds = clouds.filter(c => c.x - scrollOffset + 100 > 0);
  collectibles = collectibles.filter(c => c.x - scrollOffset + 20 > 0);
  
  // Wolken zeichnen
  fill(255, 255, 255, 200);
  noStroke();
  for (let cloud of clouds) {
    let cx = cloud.x - scrollOffset;
    ellipse(cx, cloud.y, 80, 50);
    ellipse(cx + 40, cloud.y, 60, 40);
    ellipse(cx - 40, cloud.y, 60, 40);
  }
  
  // Bäume zeichnen
  for (let tree of trees) {
    let tx = tree.x - scrollOffset;
    fill(139, 69, 19);
    rect(tx - 10, tree.y - 40, 20, 40);
    fill(34, 139, 34);
    triangle(tx - 30, tree.y - 40, tx + 30, tree.y - 40, tx, tree.y - 80);
  }
  
  // Plattformen und Inseln zeichnen (dunkleres Grün)
  fill(100, 200, 100);
  for (let platform of platforms) {
    let platformScreenX = platform.x - scrollOffset;
    rect(platformScreenX, platform.y, platform.w, platform.h, 10);
  }
  for (let island of islands) {
    let islandScreenX = island.x - scrollOffset;
    rect(islandScreenX, island.y, island.w, island.h, 10);
  }
  
  // Collectibles zeichnen
  for (let coll of collectibles) {
    let cx = coll.x - scrollOffset;
    if (coll.type === 'life') {
      fill(255, 215, 0);
      star(cx + 10, coll.y + 10, 5, 10, 5);
    } else if (coll.type === 'checkpoint') {
      fill(255, 0, 0);
      triangle(cx, coll.y, cx + 20, coll.y + 10, cx, coll.y + 20);
    }
  }
  
  // Spieler zeichnen (mit Rotation und Punkt)
  push();
  translate(player.x + player.w / 2, player.y + player.h / 2);
  rotate(player.rotation);
  fill(255, 215, 0);
  ellipse(0, 0, player.w, player.h);
  fill(0);
  ellipse(10, 0, 5, 5);
  pop();
  
  // Score und Lives anzeigen
  fill(255, 105, 180);
  textSize(24);
  text('Punkte: ' + floor(score / 10), 10, 30);
  text('Leben: ' + lives, 10, 60);
  
  // Score basierend auf Distanz
  if (scrollSpeed > 0) {
    score += scrollSpeed;
  }
}

function keyPressed() {
  if (keyCode === 32 && player.jumpsLeft > 0) {
    player.vy = jumpForce;
    player.jumpsLeft--;
    player.rotationSpeed = TWO_PI / 60;
  }
  if (key === 'F') {
    fullscreen(!fullscreen());
  }
}

function star(x, y, radius1, radius2, npoints) {
  let angle = TWO_PI / npoints;
  let halfAngle = angle / 2.0;
  beginShape();
  for (let a = 0; a < TWO_PI; a += angle) {
    let sx = x + cos(a) * radius2;
    let sy = y + sin(a) * radius2;
    vertex(sx, sy);
    sx = x + cos(a + halfAngle) * radius1;
    sy = y + sin(a + halfAngle) * radius1;
    vertex(sx, sy);
  }
  endShape(CLOSE);
}

function gameOver() {
  gameState = 'gameover';
  noLoop();
  restartButton = createButton('Nochmal spielen!');
  restartButton.position(width / 2 - 50, height / 2);
  restartButton.mousePressed(resetGame);
}
</script>
</body>
</html>
